//StiDetectorTreeBuilder.h
//M.L. Miller (Yale Software)
//07/01

/*! \class StiDetectorTreeBuilder
  StiDetectorTreeBuilder is a utility class that uses objects it gets from two
  factories
  to Build a full model of the STAR detector material.  StiDetectorTreeBuilder
  is the
  class responsible for actually organizing the StiDetector objects into a tree
  structure.
  As such, it uses the utility class StiDetectorBuilder to generate StiDetector
  objects, and
  then these objects are organized as belonging to an
  StiDetectorNode
  object.  This is all accomplished via the call to Build().
  <p>
  The general flow of execution is as follows.  First, in the constructor of
  StiDetectorTreeBuilder, the member mDetectorBuilder is set to point to an
  instance
  of StiCodedDetectorBuilder created on the heap.  Once a call to Build() is
  made, the
  tree is assembled by looping on detectors that are generated by
  mDetectorBuilder.  Each
  detector object returned by the mDetectorBuilder is then hung on the tree by
  a call to
  AddToTree which calls HangWhere().  By using mDetectorBuilder polymorphically,
  StiDetectorTreeBuilder becomes extremely flexible.  That is, it does not
  care how the
  StiDetector objects are created (e.g., from Root macro, data base, or geant).
  However,
  to really take advantage of this flexibility one should remove ownership of
  mDetectorBuilder from StiDetectorTreeBuilder and instead set the polymorphic
  pointer
  by hand before a call to Build().  This is work to be done.
  
  \author M.L. Miller (Yale Software)
  \warning There is <b>some</b> internal protection against Build being called
  more then once.  See the documenation for the Build() method.
  \warning Member of type StiDetectoBuilder* defaults to
  StiCodedDetectorBuilder.
 */

/** \example StiDetectorTreeBuilder_ex.cxx
 */

#ifndef StiDetectorTreeBuilder_HH
#define StiDetectorTreeBuilder_HH

#include <vector>
using std::vector;
#include "StiFactory.h"
#include "StiDetectorNode.h"
#include "StiDetector.h"
#include "StiToolkit.h"
class StiDetectorTreeBuilder {
 public:
  StiDetectorTreeBuilder() : mRoot(0), mnodefactory(StiToolkit::instance()->DetectorNodeFactory()), mregion(0) {}
  virtual ~StiDetectorTreeBuilder() {}
  //!Build the Detector model.
  /*! There is <b>some</b> internal protection against Building more than one instance of the
    detector model.  That is, StiDetectorTreeBuilder stores a pointer to the Root of
    the tree that it Builds.  Build() first checks that this pointer is null.  If not,
    the call to Build() will return 0.  However, once the StiDetectorTreeBuilder instance
    that originally built the tree goes out of scope, so does the stored pointer to the
    Root, and thus the protection becomes impossible.
    Additionaly, the Root of the tree is assumed to be owned by the nodefactory.
  */
  StiDetectorNode* Build();
  void SortTree();
  //!Actually hang an individual detector object on the tree.
  void AddToTree(StiDetector*);
 protected:
  //!Assemble detector objects into tree.
  void BuildRoot();
  //!Decide where to hang the detector object on the tree.
  StiDetectorNode* HangWhere(StiDetectorNode* parent, const StiOrderKey& order,
			     TString& keystring);
  //!Store a pointer to the Root of the tree.
  StiDetectorNode* mRoot;
  //!This object is assumed <b>not</b> to be owned by this class
  //!Store a pointer to the factory of tree nodes.
  //!This is used for internal convenience.  This object is <b>not</b> owned by this class.
  Factory<StiDetectorNode>* mnodefactory;
  //!Pointer to the current region in the tree (e.g., mid rapidity)
  StiDetectorNode* mregion;
};

#endif
