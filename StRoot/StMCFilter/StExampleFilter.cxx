// @(#)root/eg:$Id: StExampleFilter.cxx,v 1.7 2010/07/29 19:19:41 jwebb Exp $
// Author: Victor Perev  17/03/2009

//______________________________________________________________________________
#include "stdlib.h"
#include "math.h"

#include "StExampleFilter.h"
#include "StGenParticle.h"
#include "TMath.h"
#include "StMessMgr.h" 
/// 	IMPORTANT IMPORTANT IMPORTANT
/// Defining the static instance of user filter provides creating this
/// class during the loading of library. Afterward GEANT could select 
/// the needed filter by name. 
/// more info in http://www.star.bnl.gov/~perev/SIM/mcFilter.pdf
///
/// The libraries in loadlibs.kumac must be loaded prior to 
/// setting up the filter in the kumac.
///
/// See filt.kumac for details.

static StExampleFilter qwerty;

/// StMCFilter base class is :
/// 1. A user interface. User must overload functions:
/// 	a)RejectEG (StGenParticles &) ? called inside Pythia. Interaction point
/// 	  in (0,0,0); EG == EventGenerator
/// 	b)RejectGT (StGenParticles &) ? called inside Geant before tracking.
/// 	  Interaction point generated by Geant; GT==GeantTracking
/// 	c)RejectGE (StGenParticles &) ? called inside Geant after tracking;
/// 	  GE==GeantEnd
/// 2. All three methods have exactly the same input arguments;
/// 3. User must provide the unique name of the his filter. Selection of filter is
///    based on this name.
/// 4. Apart of that in this base class all the machinery of connection to Pythia
///    and Geant is hidden
/// 5. At the end Finish() is called. Print statistics. Could be overloaded
/// 
/// An argument of RejectXX(StGenParticles &Ptl)
/// Class StGenParticles is a container class containing StGenParticle objects.
/// Each object represents one particle(track). User methods of StGenParticles
/// class:
/// 1. Ptl.Size() ? number of particles;
/// 2. Ptl(index) ? pointer to particle (StGenParticle*)
/// 3. Ptl.Print() ? print all particles;
/// 4. Ptl.Print(char* tit) ? print container
/// 
/// Class StGenParticle ideologically is based on HEPEVT standard
/// http://cepa.fnal.gov/psm/simulation/mcgen/lund/pythia_manual/pythia6.3/pythia6301/node39.html
/// 
/// Methods:
///   - int GetStatusCode; 			/// 1= final particle
///   - int GetPdgCode; 			//PDG particle code
///   - int GetGeaCode(); 			//Geant particle code
///   - StGenParticle *GetMother(int i); 	//mother particle(0=beam,1=target)
///   - StGenParticle *GetDaughter(int i); 	//daughter ith particle
///   - double GetCalcMass ();		//calculated mass
///   - double GetMass(); 			//mass
///   - int GetNDaughters
///   - void Momentum(double p4[4]); //four momentum
///   - void Vertex(double v[3]) //vertex in cm;
///   - double Time(); //time in cm
///   - int IsPrimary(); //Is this particle a primary one?
///   - int IsFinal () //Is this particle a final one?
/// 
/// Additional methods:
///   - double R (); //Rxy of vertex
///   - double Rho (); //Rxyz of vertex
///   - double P (); /// Full momentum
///   - double Pt (); //Transverse momentum
///   - double Energy();
///   - double Eta (); //Pseudo rapidity
///   - double Phi ();
///   - double Theta ();
/// 
///     		Filter kumac commands
/// 	gexec $STAR_LIB/geometry.so
/// 	gexec $STAR_LIB/libpythia_6410t.so
/// 	gexec $STAR_LIB/bpythia.so
/// 	gexec $STAR_LIB/StMCFilter.so
/// 	gfilter filterName
/// All three methods are called in a proper places. Method which is not
/// overloaded, always returns zero (no rejection)
/// 



//______________________________________________________________________________
int StExampleFilter::RejectEG(const StGenParticleMaster &ptl) const
{
#if 0
  ptl.Print("************** In RejectEG ************** ");
// Condition: number of tracks etaGate[0]<eta<= etaGate[1] must be bigger  etaGate[2]
//const static double etaGate[3]={0.8,1.2, 3};
  const static double etaGate[3]={1.5,2.5, 1};
  const StGenParticle *tk=0;
  int n = ptl.Size();
  int ntk=0;
  for (int i=0;i<n;i++) {
    tk = ptl(i); if (!tk) 	continue;
    if (tk->GetStatusCode()!=1) continue;
    if (tk->Eta() < etaGate[0]) continue;
    if (tk->Eta() > etaGate[1]) continue;
    ntk++;
  }

  if (ntk<etaGate[2]) return 1;
#endif
  return 0;
}
//______________________________________________________________________________
int StExampleFilter::RejectGT(const StGenParticleMaster &ptl) const
{
  return 0;
}
//______________________________________________________________________________
int StExampleFilter::RejectGE(const StGenParticleMaster &ptl) const
{
#if 1
  //  ptl.Print("************** In RejectGE ************** ");
  // Condition: K0S->pi+ pi-, Gamma->e+e-,Lambda->p pi-; LambdaBar -> pbar pi+; with pT > 0.5 withing TPC fiducial volume
  //  ptl.Print("************** In RejectGT ************** ");
  const StGenParticle *tk=0;
  Int_t n = ptl.Size();
  Int_t ntk=0;
  for (Int_t i=0;i<n;i++) {
    tk = ptl(i); if (!tk) 	continue;
    if (tk->R()  > 100) continue;
    if (tk->Pt() < 0.5) continue;
    Int_t gId = tk->GetPdgCode();
    if (! tk->GetDaughter(0) ||
	! tk->GetDaughter(1)) continue;
    if (gId == 22) ntk++;
    else if (gId == 310) {
      if (TMath::Abs(tk->GetDaughter(0)->GetPdgCode()) == 211) {
	LOG_INFO << "Accept " << gId << " R = " << tk->R() << " (cm), pT = " << tk->Pt() << " (GeV/c) , daughter = " << tk->GetDaughter(0)->GetPdgCode() <<endm;
	tk++;
      }
    } else if (TMath::Abs(gId) == 3122) {
      if (TMath::Abs(tk->GetDaughter(0)->GetPdgCode()) ==  211 || 
	  TMath::Abs(tk->GetDaughter(0)->GetPdgCode()) == 2212) {
	LOG_INFO << "Accept " << gId << " R = " << tk->R() << " (cm), pT = " << tk->Pt() << " (GeV/c)" 
		 << ", daughter0 =" << tk->GetDaughter(0)->GetPdgCode() 
		 << ", daughter1 =" << tk->GetDaughter(1)->GetPdgCode() <<endm;
	ntk++;	
      }
    }
  }
  if (! ntk) return 1;
#endif
  return 0;
}
