//StxKTNIterator.h
//M.L. Miller (Yale Software)
//12/01

/*! \class StxKTNIterator
  This class is an STL compliant forward iterator that will traverse from
  the leaf of a tree upward to a Root.

  \author M.L. Miller (Yale Software)
  \note We use the defualt copy/assignment generated by compiler.
  \note Singularity (i.e., 'end') is represented by setting mNode=0.
  \note StxKTNIterator is a non-virtual class.
*/
#ifndef StxKTNIterator_HH
#define StxKTNIterator_HH

#include <assert.h>
#include "StxKalmanTrackNode.h"
typedef StxKalmanTrackNode KTN_t;
class StxKTNIterator;
typedef StxKTNIterator StxKTNBidirectionalIterator;


//This is a temp hack to get around old gcc ansi-non-compliant STL implementation
class StxKTNIterator
{
public:
    
    ///ctr-dstr
    StxKTNIterator(KTN_t* leaf=0,int dir=0) : mDir(dir),mNode( leaf) {};
    StxKTNIterator(KTN_t& leaf  ,int dir=0) : mDir(dir),mNode(&leaf) {};
    StxKTNIterator   begin();
    StxKTNIterator  rbegin();

    ///equality:
    bool operator==(const StxKTNIterator& rhs) const;

    ///inequlity
    bool operator!=(const StxKTNIterator& rhs) const;

    ////Dereference
    KTN_t& operator*();
    KTN_t* operator()();
    
    ///prefix
    StxKTNIterator& operator++ ();
    
    ///postfix
    StxKTNIterator operator++(int);

    ///prefix
    StxKTNIterator& operator-- ();
    
    ///postfix
    StxKTNIterator operator--(int);

    ///We demarcate the end of the traversal via  a singular iterator
static const StxKTNIterator&  end();
static const StxKTNIterator& rend();

static    StxKTNIterator   begin(KTN_t* fist);
static    StxKTNIterator  rbegin(KTN_t* last);


private:
    int mDir;
    KTN_t* mNode;
};

class StxKTNForwardIterator: public StxKTNIterator{
public:
    StxKTNForwardIterator(KTN_t* leaf=0) : StxKTNIterator(leaf,1){};
    StxKTNForwardIterator(KTN_t& leaf  ) : StxKTNIterator(leaf,1){};
static const StxKTNForwardIterator& end();
};

//inlines --

inline bool StxKTNIterator::operator==(const StxKTNIterator& rhs) const
{
    return mNode==rhs.mNode;
}

inline bool StxKTNIterator::operator!=(const StxKTNIterator& rhs) const
{
    return !(mNode==rhs.mNode);
}

inline KTN_t& StxKTNIterator::operator*()
{
    return *mNode;
}
inline KTN_t* StxKTNIterator::operator()()
{
    return mNode;
}

//prefix
/*! In the case where the prefix operator increments beyond the Root of the tree,
  the pointer to mNode is set to 0.   This demarcates the end of the traversal.
 */
inline StxKTNIterator& StxKTNIterator::operator-- ()
{
    mDir = !mDir;
    ++(*this);
    mDir = !mDir;
    return *this;
}
    

//postfix
/*! In the case where the prefix operator increments beyond the Root of the tree,
  the pointer to mNode is set to 0.   This demarcates the end of the traversal.
*/
inline StxKTNIterator StxKTNIterator::operator++(int)
{
    StxKTNIterator temp = *this;
    ++(*this);
    return temp;
}

//prefix
/*! In the case where the prefix operator increments beyond the last leaf of the tree,
  the pointer to mNode is set to -.  This demarcates the end of traversal.
*/
inline StxKTNIterator& StxKTNIterator::operator++ ()
{
  assert(mNode);
  if(!mDir) { //forward direction  

    mNode = static_cast<KTN_t*>(mNode->NextNode());

  } else { //backward direction

    mNode = static_cast<KTN_t*>(mNode->PrevNode());
  }

  return *this;
}

//postfix decrement
/*! In the case where the prefix operator increments beyond the Root of the tree,
  the pointer to mNode is set to 0.   This demarcates the end of the traversal.
*/
inline StxKTNIterator StxKTNIterator::operator--(int)
{
    StxKTNIterator temp = *this;
    --(*this);
    return temp;
}


inline StxKTNIterator  StxKTNIterator::begin(KTN_t* fist)
{
  return StxKTNIterator(fist,0);
}  

inline StxKTNIterator StxKTNIterator::rbegin(KTN_t* last)
{
  return StxKTNIterator(last,1);
}  
inline StxKTNIterator  StxKTNIterator::begin()
{
  assert(mNode);
  KTN_t*  fist = (KTN_t*)mNode->FirstNode();
  return StxKTNIterator(fist,0);
}  

inline StxKTNIterator StxKTNIterator::rbegin()
{
  assert(mNode);
  KTN_t* last = (KTN_t*)mNode->LastNode();
  return StxKTNIterator(last,1);
}  

#endif
