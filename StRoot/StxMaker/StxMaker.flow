#include "TPCCATracker/AliHLTTPCCAGBHit.h"
    float fX; //* X position
    float fY; //* Y position
    float fZ; //* Z position

    float fErrX; //* X position error
    float fErrY; //* Y position error
    float fErrZ; //* Z position error

    float fAmp;   //* Maximal amplitude
    int fISlice; //* slice number
    int fIRow;   //* row number
    int fID;     //* external ID (id of AliTPCcluster)
    bool fIsUsed; //* is used by GBTracks
#include "TPCCATracker/AliHLTTPCCAGBTrack.h"
    int fFirstHitRef;        // index of the first hit reference in track->hit reference array
    int fNHits;              // number of track hits
    AliHLTTPCCATrackParam fInnerParam; // fitted track parameters
    AliHLTTPCCATrackParam fOuterParam;
    float fAlpha;             //* Alpha angle of the parametrerisation
    int   fNDeDx;
    float fDeDx;              //* DE/DX

    // ---
    bool tIsMerged;
#include "TPCCATracker/AliHLTTPCCAParam.h"
    int fISlice; // slice number
    int fNRows; // number of rows
    int fNInnerRows; // number of inner rows

    float fAlpha, fDAlpha; // slice angle and angular size
    float fCosAlpha, fSinAlpha;// sign and cosine of the slice angle
    float fAngleMin, fAngleMax; // minimal and maximal angle
    float fRMin, fRMax;// slice R range
    float fZMin, fZMax;// slice Z range
    float fErrX, fErrY, fErrZ;// default cluster errors
    float fPadPitch; // pad pitch
    float fBz;       // magnetic field value (only constant field can be used)

    float fHitPickUpFactor;// multiplier for the chi2 window for hit pick up procedure

    int   fMaxTrackMatchDRow;// maximal jump in TPC row for connecting track segments
    float fTrackConnectionFactor; // allowed distance in Chi^2/3.5 for neighbouring tracks
    float fTrackChiCut; // cut for track Sqrt(Chi2/NDF);
    float fTrackChi2Cut;// cut for track Chi^2/NDF

    vector<float> fRowX;// X-coordinate of rows 
    int   fRecoType;		   // 0=Sti error parametrization; 1=Stv
    float fParamS0Par[2][3][7];    // cluster error parameterization coeficients
    float fPolinomialFieldBz[6];   // field coefficients
#include "TPCCATracker/AliHLTTPCCATrackParam.h"
    float fX;      // x position
    float fSignCosPhi; // sign of cosPhi   // phi = arctg (Dy/Dx)
    float fP[5];   // 'active' track parameters: Y, Z, SinPhi, Dz/Ds (ds = sqrt( dx^2 + dy^2 )), q/Pt
    float fC[15];  // the covariance matrix for Y,Z,SinPhi,..
    float fChi2;   // the chi^2 value
    int   fNDF;    // the Number of Degrees of Freedom

================================================================================


       
    StxMaker::Make
      StxCAInterface::SetNewEvent()   - clean fSeedFinder, fSeeds, 
        StTPCCAInterface::SetNewEvent - clean fIdTruth, fCaParam, fCaHits, fTracker
      StxCAInterface::Run
	StTPCCAInterface::Run
           StTPCCAInterface::MakeSettings
           MakeHits
             StxCAInterface::MakeHits()
		Id = fCaHits.size();
          	hitc.track_key=tpcHit->idTruth();
	        hitc.hit  = tpcHit;
	        hitc.Id = Id;
                fSeedHits.push_back(hitc);
	        fCaHits.push_back(caHit);

           AliHLTTPCCAGBTracker::SetSettings(fCaParam);
           AliHLTTPCCAGBTracker::SetHits(fCaHits);
           AliHLTTPCCAGBTracker::FindTracks		    
             AliHLTTPCCATracker::ReadEvent			    
               AliHLTTPCCATracker::StartEvent		    
                 AliHLTTPCCATracker::SetupCommonMemory	    
               AliHLTTPCCASliceData::InitFromClusterData	    
               AliHLTTPCCASliceData::NumberOfHits 		    
             AliHLTTPCCATracker::Reconstruct		    
               AliHLTTPCCATracker::Reconstructor::Reconstructor
           MakeSeeds();
             StxCAInterface::MakeSeeds
	       seed.vhit.push_back(fSeedHits[hId].hit);
               fSeeds.push_back(seed);

================================================================================
StixSeedFinder:
  StxNodePars copy of StiNodePars
  StxNodeErrs -"-     StiNodeErrs
  SeedHit_t
      const StTpcHit  *hit;
      Int_t      Id; // from CA
     	
  Seedx_t             Keeps CA seeds
     vector<const StTpcHit *> vhit;
     StxNodePars firstNodePars;
     StxNodePars lastNodePars;
     StxNodeErrs firstNodeErrs;
     StxNodeErrs lastNodeErrs;
    
   StxSeedFinder
      std::vector<Seedx_t> *mSeeds; 
================================================================================
StxMaker::FitTrack(const AliHLTTPCCAGBTrack &tr)
  // init fitter
  genfit::AbsKalmanFitter* fitter = 0;
...
       case genfit::RefKalman:
      fitter = new genfit::KalmanFitterRefTrack(nIter, dPVal);
      fitter->setMultipleMeasurementHandling(mmHandling);
      break;
...
  genfit::FieldManager::getInstance()->useCache(true, 8);
  genfit::MaterialEffects::getInstance()->init(new genfit::TGeoMaterialInterface());
  const int pdg = -13;               // particle pdg code mu+
...
  //========== Reference  track ======================================================================
  Double_t sign = ConvertCA2XYZ(tr, pos, mom, covM);
  genfit::AbsTrackRep* rep = new genfit::RKTrackRep(sign*pdg);
...
  genfit::MeasuredStateOnPlane stateRef(rep);
  genfit::Track  fitTrack(rep, pos, mom);
  rep->setPosMomCov(stateRef, pos, mom, covM);
     genfit::RKTrackRep::setPosMomCov
  rep->setPropDir(1);
  const genfit::StateOnPlane stateRefOrig(stateRef);
  //========== Mesurements ======================================================================
  const int NHits = tr.NHits();
  for ( int iHit = 0; iHit < NHits; iHit++ ){ 
...
   TVectorD HitCoords(2);
    HitCoords[0] = xyzL[1];
    HitCoords[1] = xyzL[2];
    TMatrixDSym hitCov(2);
    Double_t zL = xyzL[2] + ((TGeoBBox *)nodeP->GetVolume(-1)->GetShape())->GetDZ();
    Double_t ecross, edip;
    errCalc->calculateError(zL, pars.eta(), pars.tanl(), ecross, edip);
    hitCov(0,0) = ecross;
    hitCov(1,1) = edip;
    genfit::PlanarMeasurement* measurement = new genfit::PlanarMeasurement(HitCoords, hitCov, detId, ++hitId, nullptr);
    measurement->setPlane(genfit::SharedPlanePtr(new genfit::DetPlane(TVector3(D.GetTranslation()), TVector3(D.GetRotationMatrix()+3), TVector3(D.GetRotationMatrix()+6))), ++planeId);
    fitTrack.insertPoint(new genfit::TrackPoint(measurement, nullptr));
...

  fitTrack.checkConsistency();
  fitter->processTrack(&fitTrack);
    genfit::AbsFitter::processTrack
      genfit::KalmanFitterRefTrack::processTrackWithRep
        genfit::KalmanFitterRefTrack::prepareTrack
          genfit::KalmanFitterRefTrack::removeOutdated 
...
          // loop over TrackPoints
          genfit::RKTrackRep::extrapolateToPlane
            genfit::RKTrackRep::Extrap
              genfit::RKTrackRep::RKutta
                genfit::RKTrackRep::estimateStep
                  genfit::MaterialEffects::stepper
                    genfit::TGeoMaterialInterface::initTrack
                      TGeoManger::IsSameLocation
                      TGeoManger::SetCurrentDirection
                    genfit::TGeoMaterialInterface::findNextBoundary
                      TGeoManager::FindNextBoundary
                        TGeoNavigator::FindNextBoundary
  fitTrack.getFittedState().Print();
    genfit::Track::getFittedState(int id = 0, const AbsTrackRep* rep = nullptr, bool biased = true) 
    genfit::MeasuredStateOnPlane::Print
  fitTrack.checkConsistency();



================================================================================
    M1x7 state7;

    state7[0] = pos.X();
    state7[1] = pos.Y();
    state7[2] = pos.Z();

    state7[3] = mom.X();
    state7[4] = mom.Y();
    state7[5] = mom.Z();
    norm = 1. / sqrt(state7[3]*state7[3] + state7[4]*state7[4] + state7[5]*state7[5]);
    state7[6] = getCharge(state) * norm;

void RKTrackRep::getState5(StateOnPlane& state, const M1x7& state7) const 

  const TVector3& O(state.getPlane()->getO());
  const TVector3& U(state.getPlane()->getU());
  const TVector3& V(state.getPlane()->getV());
  const TVector3& W(state.getPlane()->getNormal());
  // force A to be in normal direction and set spu accordingly
  double AtW( state7[3]*W.X() + state7[4]*W.Y() + state7[5]*W.Z() );
  if (AtW < 0.) {
    //fDir *= -1.;
    //AtW *= -1.;
    spu = -1.;
  }

  state5[0] = state7[6]; // q/p
  state5[1] = (state7[3]*U.X() + state7[4]*U.Y() + state7[5]*U.Z()) / AtW; // u' = (A * U) / (A * W)
  state5[2] = (state7[3]*V.X() + state7[4]*V.Y() + state7[5]*V.Z()) / AtW; // v' = (A * V) / (A * W)
  state5[3] = ((state7[0]-O.X())*U.X() +
               (state7[1]-O.Y())*U.Y() +
               (state7[2]-O.Z())*U.Z()); // u = (pos - O) * U
  state5[4] = ((state7[0]-O.X())*V.X() +
               (state7[1]-O.Y())*V.Y() +
               (state7[2]-O.Z())*V.Z()); // v = (pos - O) * V

  setSpu(state, spu);


  const double qop = state7[6];
  const double p = getCharge(state)/qop; // momentum
  // J_Mp matrix is d(q/p,u',v',u,v) / d(x,y,z,px,py,pz)       (in is 6x6)
//
//    state7 - initial parameters (coordinates(cm), direction,
//             charge/momentum (Gev-1)
//    cov      and derivatives this parameters  (7x7)
//
//    X         Y         Z         Ax        Ay        Az        q/P
//    state7[0] state7[1] state7[2] state7[3] state7[4] state7[5] state7[6]
//
//    dX/dp     dY/dp     dZ/dp     dAx/dp    dAy/dp    dAz/dp    d(q/P)/dp
//    cov[ 0]   cov[ 1]   cov[ 2]   cov[ 3]   cov[ 4]   cov[ 5]   cov[ 6]               d()/dp1
//
//    cov[ 7]   cov[ 8]   cov[ 9]   cov[10]   cov[11]   cov[12]   cov[13]               d()/dp2
//    ............................................................................    d()/dpND
//
// Authors: R.Brun, M.Hansroul, V.Perevoztchikov (Geant3)
