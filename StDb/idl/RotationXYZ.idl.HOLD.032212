//:Description: RotationXYZ data
//:Synonyms::::
//:Source:
//:Update:
//:Update frequncy:
//:Reminder:
//:Recall frequency:
//:Size of Data:
//:Pointer to data:  RotationXYZ.time.C:
//   Translation from local to Master
//   m = R*l + t
//   Rotation matrix R is defined via rotation angles alpha (around X), beta (around Y) and gamma (around Z)
//   alpha, beta and gamma are in degrees
//   R = RotationZ(gamma)*RotationY(beta)*RotationX(alpha);
//    Double_t ca = TMath::Cos(alpha); Double_t sa = TMath::Sin(alpha);
//    Double_t cb = TMath::Cos(beta) ; Double_t sb = TMath::Sin(beta); 
//    Double_t cg = TMath::Cos(gamma); Double_t sg = TMath::Sin(gamma);
//        ( cg*cb,  cg*sb*sa-sg*ca, cg*sb*ca+sg*sa)
//    R = ( sg*cb,  sg*sb*sa   +ca, sg*sb*ca   -sa)
//	  ( -sb  ,     cb*sa      ,    cb*ca      )
//    alpha =   TMath::ATan2(rotx[7],rotx[8]);
//    beta  = - TMath::ASin(rotx[6]);
//    gamma =   TMath::ATan2(rotx[3],rotx[0]);
//
//           ( r00 r01 r02 ) (xl)   ( t0 )    ( r00 r02 r01 ) (xl)   ( t0 )
//       R = ( r10 r11 r12 ) (yl) + ( t1 ) =  ( r10 r12 r11 ) (zl) + ( t1 )
//           ( r20 r21 r22 ) (zl)   ( t2 )    ( r20 r22 r21 ) (yl)   ( t2 )
// 
struct RotationXYZ {
  long   Id;
  double alpha, beta, gamma;
  double t0, t1, t2;
  double Dalpha, Dbeta, Dgamma; // errors in mrad
  double Dt0, Dt1, Dt2;         // errors in mkm
  char   comment[32];
};
