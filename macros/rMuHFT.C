/* 
   root.exe 'lMuDst.C(0,"st_physics_15089024_raw_1500001_1_5000.MuDst.root")' 'rMuHFT.C+(100)'
*/
#if !defined(__CINT__) || defined(__MAKECINT__)
#include <assert.h>
#include <map>
#include <utility>
#include "Riostream.h"
#include "Rtypes.h"
#include "TROOT.h"
#include "TSystem.h"
#include "TH1.h"
#include "TH2.h"
#include "TH3.h"
#include "TF1.h"
#include "TProfile.h"
#include "TProfile3D.h"
#include "TTree.h"
#include "TChain.h"
#include "TCanvas.h"
#include "TLegend.h"
#include "TClassTable.h"
#include "TFile.h"
#include "TChain.h"
#include "TString.h"
#include "SystemOfUnits.h"
#include "StBFChain/StBFChain.h"
#include "StMuDSTMaker/COMMON/StMuTimer.h"
#include "StMuDSTMaker/COMMON/StMuDebug.h"
#include "StMuDSTMaker/COMMON/StMuDst.h"
#include "StMuDSTMaker/COMMON/StMuEvent.h"
#include "StMuDSTMaker/COMMON/StMuTrack.h"
#include "StMuDSTMaker/COMMON/StMuPrimaryVertex.h"
#include "StMuDSTMaker/COMMON/StMuMcVertex.h"
#include "StMuDSTMaker/COMMON/StMuMcTrack.h"
#include "StMuDSTMaker/COMMON/StMuPrimaryTrackCovariance.h"
#include "StarRoot/TPolynomial.h"
#include "StDcaGeometry.h"
#include "TRSymMatrix.h"
#include "THelixTrack.h"
#include "Names.h"
#include "StBichsel/Bichsel.h"
#define ClassStMessMgr
#define StMessMgr Int_t
#include "StMuDSTMaker/COMMON/StMuDstMaker.h"
#undef  StMessMgr
#undef ClassStMessMgr
#else
#ifndef __MAKECINT__
#define BIT(n)       (1 << (n))
#define SETBIT(n,i)  ((n) |= (1 << i))
#define CLRBIT(n,i)  ((n) &= ~(1 << i))
#define TESTBIT(n,i) ((Bool_t)(((n) & (1 << i)) != 0))
class StMuDstMaker;
#endif
#endif
enum TrackMatchType {kPositive, kNegative, kTotalSigns};                                     // switch between charges
struct PlotName_t {
  TrackMatchType    k;
  const Char_t *Name;
  const Char_t *Title;
};
struct VarName_t {
  const Char_t *Name;
  const Char_t *Title;
  Int_t nx;
  Double_t xmin, xmax;
  Int_t ny;
  Double_t ymin, ymax;
  Int_t nz;
  Double_t zmin, zmax;
  Double_t  min,  max; // min and max for plots
};
const Char_t *NameCharge[kTotalSigns] = {"Pos", "Neg"};
const Char_t *TitleCharge[kTotalSigns] = {"(+)", "(-)"};
//________________________________________________________________________________
static Int_t _debug = 0;
void SetDebug(Int_t k) {_debug = k;}
Int_t Debug() {return _debug;}
//________________________________________________________________________________
//________________________________________________________________________________
Bool_t Accept(const StMuTrack *gTrack = 0) {
  if (! gTrack)            return kFALSE;
  //  if (! gTrack->idTruth()) return kFALSE;
  if (! gTrack->charge())  return kFALSE;
  if (  gTrack->flag() < 100 ||  gTrack->flag()%100 == 11) return kFALSE; // bad fit or short track pointing to EEMC
  if (  gTrack->flag() > 1000) return kFALSE;  // pile up track in TPC
  if (  gTrack->nHitsFit() < 15) return kFALSE;
  //  if (  gTrack->qaTruth() < 90) return kFALSE;
  return kTRUE;
}
//________________________________________________________________________________
Bool_t AcceptVX(const StMuPrimaryVertex *Vtx = 0) {
  if (! Vtx) return kFALSE;
  if (TMath::Abs(Vtx->position().z()) > 5) return kFALSE;
  //  if (! Vtx->idTruth())  return kFALSE;
  //  if (  Vtx->qaTruth() < 90) return kFALSE;
  return kTRUE;
}
//________________________________________________________________________________
void rMuHFT(Long64_t nevent = 9999999,
	 const  char* outFile="rMuHFT.root") {
  TFile *fOut   = new TFile(outFile,"recreate");
#ifdef  __PRIMARY_TRACKS__
  TH1F *VxZ     = new TH1F("VxZ","Vertex Z",20,-10.,10.);
  TH2F *EtapT   = new TH2F("EtapT","track #eta versu pT",100,-1,1,100,0.,5.);
#endif /*  __PRIMARY_TRACKS__ */
  TH2F *HftHits = new TH2F("HftHist","No. of HFT hits versus no. of TPC hits",32,14.5,46.5,16,-0.5,15.5);
  StBFChain *chain = (StBFChain *) StMaker::GetTopChain();
  StMuDebug::setLevel(0);  
  StMuDstMaker* maker = (StMuDstMaker *) chain->Maker("MuDst");
  maker->SetStatus("*",0);
  const Char_t *ActiveBranches[] = {"MuEvent"
#ifdef  __PRIMARY_TRACKS__
				    ,"PrimaryVertices"
				    ,"PrimaryTracks"
#endif
				    ,"GlobalTracks"
#if 0
				    ,"CovGlobTrack"
				    ,"StStMuMcVertex"
				    ,"StStMuMcTrack"
#endif
  };
  Int_t Nb = sizeof(ActiveBranches)/sizeof(Char_t *);
  for (Int_t i = 0; i < Nb; i++) maker->SetStatus(ActiveBranches[i],1); // Set Active braches
  StMuDebug::setLevel(0);  
  TChain *tree = maker->chain();
  if (! tree) return;
  Long64_t nentries = tree->GetEntries();
  nevent = TMath::Min(nevent,nentries);
  cout << nentries << " events in chain " << nevent << " will be read." << endl;
  //  if (nentries < 100) return;
  tree->SetCacheSize(-1);        //by setting the read cache to -1 we set it to the AutoFlush value when writing
  tree->SetCacheLearnEntries(1); //one entry is sufficient to learn
  tree->SetCacheEntryRange(0,nevent);

  for (Long64_t ev = 0; ev < nevent; ev++) {
    if (chain->MakeEvent()) break;
    StMuDst* mu = maker->muDst();   // get a pointer to the StMuDst class, the class that points to all the data
    if (ev%1000 == 0) cout << "Read event\t" << ev << endl;
    StMuEvent* muEvent = mu->event(); // get a pointer to the class holding event-wise information
    // cout << " #" << ev;
    //    Int_t referenceMultiplicity = muEvent->refMult(); // get the reference multiplicity
    // cout << " refMult= "<< referenceMultiplicity;
#ifdef  __PRIMARY_TRACKS__
    TClonesArray *PrimaryVertices   = mu->primaryVertices(); 
    Int_t NoPrimaryVertices = PrimaryVertices->GetEntriesFast();  // cout << "\tPrimaryVertices " << NoPrimaryVertices;
    TClonesArray *PrimaryTracks    = mu->array(muPrimary);  
    Int_t NoPrimaryTracks = PrimaryTracks->GetEntriesFast();  // cout << "\tPrimaryTracks " << NoPrimaryTracks;
#endif
    TClonesArray *GlobalTracks     = mu->array(muGlobal);  
    Int_t NoGlobalTracks = GlobalTracks->GetEntriesFast();        if (Debug()) {cout << "\tGlobalTracks " << NoGlobalTracks;}
#if 0
    TClonesArray *CovGlobTrack     = mu->covGlobTrack();          if (Debug()) {cout << "\tCovGlobTrack " << CovGlobTrack->GetEntriesFast();}
#endif
#ifdef __PRIMARY_TRACKS__
    for (Int_t l = 0; l < NoPrimaryVertices; l++) {
      StMuPrimaryVertex *Vtx = (StMuPrimaryVertex *) PrimaryVertices->UncheckedAt(l);
      if (l) continue;
      if (! AcceptVX(Vtx)) continue; //
      VxZ->Fill(Vtx->position().z());
      //      cout << *Vtx << endl;
      for (Int_t k = 0; k < NoPrimaryTracks; k++) {
	StMuTrack *pTrack = (StMuTrack *) PrimaryTracks->UncheckedAt(k);
	if (! pTrack) continue;
        if (pTrack->vertexIndex() != l) continue;
	if (! Accept(pTrack)) continue;
	//	cout << *pTrack << endl;
	EtapT->Fill(pTrack->eta(), pTrack->pt());
	StTrackTopologyMap topologyMap = pTrack->topologyMap();
	UInt_t noPxlHits = topologyMap.numberOfHits(kPxlId); // 0-3
	UInt_t noIstHits = topologyMap.numberOfHits(kIstId); // 0-2
	UInt_t noSsdHits = topologyMap.numberOfHits(kSsdId); // 0-2
	UInt_t noHftHits = noPxlHits + 3*(noIstHits + 2*noSsdHits);
	UInt_t noTpcHits = topologyMap.numberOfHits(kTpcId); // 0-45
	HftHits->Fill(noTpcHits,noHftHits);
      }
    }
#else /* !  __PRIMARY_TRACKS__ */
    for (Int_t k = 0; k < NoGlobalTracks; k++) {
      StMuTrack *gTrack = (StMuTrack *) GlobalTracks->UncheckedAt(k);
      if (! gTrack) continue;
      if (! gTrack->idTruth()) continue;
      //      if (! Accept(gTrack)) continue;
      //	cout << *gTrack << endl;
      StTrackTopologyMap topologyMap = gTrack->topologyMap();
      Int_t noPxlHits = topologyMap.numberOfHits(kPxlId); // 0-3
      Int_t noIstHits = topologyMap.numberOfHits(kIstId); // 0-2
      Int_t noSsdHits = topologyMap.numberOfHits(kSsdId); // 0-2
      noPxlHits = TMath::Min(3, noPxlHits);
      noIstHits = TMath::Min(2, noIstHits);
      noSsdHits = TMath::Min(2, noSsdHits);
      UInt_t noHftHits = noPxlHits + 3*(noIstHits + 2*noSsdHits);
      UInt_t noTpcHits = topologyMap.numberOfHits(kTpcId); // 0-45
      HftHits->Fill(noTpcHits,noHftHits);
    }
#endif
  }
  if (fOut) fOut->Write();
}



